//=================================================================================
//文件名称：SC_Status.c
//功能概要：SC_Status驱动构件源文件
//版权所有：苏州大学飞思卡尔嵌入式中心(sumcu.suda.edu.cn)
//版    本：V1.0, 20151111
//=================================================================================
#include "SC_Status.h"
#include "adc.h"

//=================================================================================
//函数名称：SC_init
//函数返回：无
//参数说明： accurary采样精度:单端8-12-10-16；差分9-13-11-16
//         HardwareAverage硬件滤波：sample4/sample8/sample16/sample32
//功能概要：车模状态相关参数初始化,ADC初始化且统一使用单端输入模式。需使用ADC构件中
//         的函数，内部函数按照本实验室要求进行封装。
//=================================================================================
void SC_init(int MoudelNumber)
{
	//各路AD最大采样值初始化
	max_AD[0]=AD0_MAX;
    max_AD[1]=AD1_MAX;
	max_AD[2]=AD2_MAX;
	max_AD[3]=AD3_MAX;
	max_AD[4]=AD4_MAX;
	max_AD[5]=AD5_MAX;
	//各路AD最小采样值初始化
	min_AD[0]=AD0_MIN;
    min_AD[1]=AD1_MIN;
	min_AD[2]=AD2_MIN;
	min_AD[3]=AD3_MIN;
	min_AD[4]=AD4_MIN;
	min_AD[5]=AD5_MIN;
	//ADC初始化，使用单端输入
	adc_init(0);       //K60与KL25的差距，固定使用模块号0，可能需要更改
}


//==================================================================================
//函数名称： SC_EMS_Get
//函数返回：无
//参数说明：无
//功能概要：采集6路传感器的值，并进行归一化处理，存放到全局数组AD_EMS中，考虑到精度，
//         归一化后各路AD值 范围是0-1000
//==================================================================================
void SC_EMS_Get(uint8_t accurary,uint8_t N)
{
    int i=0, j=0;
	int AD[6];
	//AD采集6路传感器的值
	AD[0]= adc_ave(0,EMS_0,accurary,N);   //从左到右第0号传感器
	AD[1]= adc_ave(0,EMS_1,accurary,N);   //从左到右第1号传感器
	AD[2]= adc_ave(0,EMS_2,accurary,N);   //从左到右第2号传感器
	AD[3]= adc_ave(0,EMS_3,accurary,N);   //从左到右第3号传感器
	AD[4]= adc_ave(0,EMS_4,accurary,N);   //从左到右第4号传感器
	AD[5]= adc_ave(0,EMS_5,accurary,N);   //从左到右第5号传感器
	//按照研究生学长的求平均值不需要这么多参数，可以修改函数简化，去掉模块号精度采样次数
	//对采集的各路AD值归一化处理，范围0-1000，存放在AD_EMS数组中
	for(i=0;i<=5;i++)
	{
		AD_EMS[i]=1000*(AD[i]-min_AD[i])/(max_AD[i]-min_AD[i]);
		//越界检查
		if(AD_EMS[i]<0) AD_EMS[i]=0;
		if(AD_EMS[i]>1000) AD_EMS[i]=1000;
	}
}

//===================================================================================
//函数名称：SC_Status_Get
//函数返回：车模在跑道上的相对偏离程度，范围-100~+100
//参数说明：X为指向存放各路传感器AD值的数组的指针
//功能概要：该函数根据EMS_GET函数获得的6路归一化后的传感器值，判断车模在跑道上偏离程度
//===================================================================================
int SC_Status_Get(int *X)
{
	//车模向左完全偏离跑道
	if((X[0]<30)&&(X[1]<50)&&(X[2]<50)&&(X[3]<50)&&(X[4]<100)&&(X[5]<300))
	{
		return -100;
	}
	//车模向右完全偏离跑道
	else if((X[0]<300)&&(X[1]<100)&&(X[2]<50)&&(X[3]<50)&&(X[4]<50)&&(X[5]<30))
	{
		return +100;
	}
	else
	{
		//右偏
		if((X[0]>=60)&&(X[4]<60)&&(X[2]<400)&&(X[3]<400))
		{
			return (X[0]-X[5])/10;  //根据最两端传感器的差值得出车模偏离程度
		}
		//左偏
		else if((X[0]<60)&&(X[4]>=60)&&(X[2]<500)&&(X[3]<500))
		{
			return (X[5]-X[0])/10;  //根据最两端传感器的差值得出车模偏离程度
		}
		else if((X[5]>=500)||(X[1]>=500))
		{
			//向左直角弯
			if((X[5]-X[1]-X[4]-X[0])>500)
			{
				return  +100;
			}
			//向右直角弯
			else if((X[1]-X[5]-X[2]-X[4])>500)
			{
				return -100;
			}
			//向左十字弯
			else if((X[5]-X[2]<500)&&(X[5]-X[2]<500)&&(X[5]-X[3]>500)&&(X[0]+X[4]<500)&&(X[3]<160))
			{
				return (X[0]-X[4])/10; //为了防止 前瞻伸到对面跑道，使用最左和最右第二个传感器值
			}
			//右十字弯
			else if((X[1]-X[3]<500)&&(X[1]-X[5]<500)&&(X[1]-X[2]>500)&&(X[0]+X[4]<200)&&(X[2]<80))
			{
				return (X[1]-X[5])/10; //为了防止前瞻伸到对面跑道，使用最右和最左第二个传感器值
		    }
		}

	}

}




